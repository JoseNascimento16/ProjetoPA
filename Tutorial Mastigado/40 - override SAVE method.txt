A idéia aqui é a seguinte: 
   
	O metodo save() quando executado, ele retorna alguns **kwargs por padrão, o objetivo é que possamos manipular alguns desses argumentos 	para que possamos ter mais maleabilidade nas nossas ações.

	Iremos sobrescrever o save() para um modelo específico, portanto:

Em models.py

	- Dentro da classe que especifica um modelo:

		class Classificacao(models.Model):
    			user = models.OneToOneField(User, on_delete=models.CASCADE)
    			tipo_de_acesso = models.CharField(max_length=50)

    			def __str__(self):
        		   return self.user.first_name

    			def save(self, *args, **kwargs):
            			if self.pk:
                		   # If self.pk is not None then it's an update.
                		   cls = self.__class__
                		   old = cls.objects.get(pk=self.pk)
                		   # This will get the current model state since super().save() isn't called yet.
                		   new = self  # This gets the newly instantiated Mode object with the new values.
                	   	   changed_fields = []
               			   for field in cls._meta.get_fields():
                    			field_name = field.name
                    			try:
                        		   if getattr(old, field_name) != getattr(new, field_name):
                            			changed_fields.append(field_name)
                    			except Exception as ex:  # Catch field does not exist exception
                        		   pass
                		   kwargs['update_fields'] = changed_fields
            			super().save(*args, **kwargs)
	
	- Ou seja, neste caso específico, o save() para esta classe irá setar uma variável do kwargs chamada "update_fields" em TRUE ou FALSE e 	   	  isso irá nos dar a capacidade de saber se algum campo foi alterado.
