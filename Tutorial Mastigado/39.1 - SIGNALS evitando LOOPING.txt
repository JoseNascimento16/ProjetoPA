A forma mais elegante que encontrei de evitar o looping ao salvar uma instancia de objeto dentro de um signals foi a seguinte:

- No modelo de classe do objeto, criamos um método de SAVE personalizado:

def save_without_signals(self):
        # This allows for updating the model from code running inside post_save()
        # signals without going into an infinite loop:
        self._disable_signals = True
        self.save()
        self._disable_signals = False

- No SIGNALS ao salvar, utilizamos este método com o seguinte argumento no IF:

def my_model_post_save(sender, instance, *args, **kwargs):
    if not getattr(instance, '_disable_signals', False):
        instance.atributo = 'valor modificado'
	instance.save_without_signals()

Portanto, aqui no SIGNALS, salvamos a instancia utilizado o metodo de save 'save_without_signals()', e dessa forma, o SIGNAL não entra em looping.
