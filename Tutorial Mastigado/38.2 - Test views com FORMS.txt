- Resposta de "Bruce Wayne"

	https://stackoverflow.com/questions/46449463/django-test-client-submitting-a-form-with-a-post-request


- Para views com formsets: Resposta de djvg

	https://stackoverflow.com/questions/1630754/django-formset-unit-test

##########################################################################################

Somente o uso da estrutura:

data = {'email':'someone@email.com'}
response = self.c.post('/profile/altera_email/1', data, follow=True)

Já é suficiente para o teste funcionar.

#########################################################################################

FORMS COM PREFIXOS!!

Porém, se na nossa views, houver um form com prefixo, temos que fazer diferente, senão da erro

Na views:
 form = FormAlteraMail(request.POST, user_id_super=user_id, prefix='prefixoQUALQUER')
No teste:
 data = {
	'prefixoQUALQUER-email':'someone@email.com',
	'prefixoQUALQUER-username':'someone'
	}

Perceba que temos que colocar o prefixo manualmente no teste, antes do nome do campo, para só assim funcionar (fazer isso para todos os campos que pegam o prefixo)
Alguns campos como o ID, recebem um id-prefixo-campo antes do valor do prefixo
Se quisermos saber exatamente como o nome dos fields estarão no html, basta ir no HTML > botão direito > Exibir codigo fonte da pagina

VIEWS COM 2 FOMRULÁRIOS no MESMO REQUEST

- Para views que recebam mais de um formulário (cada um com um prefixo), teremos a seguinte estrutura de dados no tests:
data_1 = {
         'prefixoA-identificacao_numerica':'1',
         'prefixoA-descricao_do_problema':'b',
         'prefixoA-resultados_esperados':'c',
         }
data_2 = {
         'prefixoB-identificacao':'A',
         'prefixoB-especificacao':'b',
          }
data = {**data_1, **data_2}

        response = self.c.post(reverse('chama_corrige_ordem', kwargs=kwargs), data)

Dessa forma, o "data" é passado para o request com os respectivos dados dos formularios

########################################################################################

# Queryset, CHOICES. Ao testar uma views que tem um campo do form preenchido com queryset. temos que passar o ID dos objetos do queryset
# Não podemos passar nem o OBJETO em si, tem que ser o ID
   data = {'campo':self.modelo.id}
   - para ajudar no debug, podemos dar um print(form_com_erro) ou print(form_com_erro['campo']) e nesse print mostra a estrutura do field choices

# Um erro que é comum de acontecer é um teste de queryset com choices passar individualmente, porém falhar quando fazemos o teste geral da pasta test_views.(ModeloFiaForm)
# Isso acontece porque no teste individual, ele só gera os objetos que serão usados ali na hora(id=1,2) e no teste geral pode acontecer de varios objetos ja terem sido criados(id=1,2,3,4,5,6,7,8,9...)
   - Este nosso erro aconteceu porque nós não estávamos passando um objeto especifico para o SUPER no form, que por sua vez era utilizado para renderizar o CHOICESFIELD:
	- No teste individual isso não era problema, pois no form (sem o SUPER) ele renderizava esses campos utilizando os objetos de forma generica.
	- No teste geral falhava porque, a renderização generica não considerava que, por exemplo, dos 9 objetos já existentes, ele tinha que utilizar 			  os objetos de "id= 8 e 9" e acabava usando os genericos (id=1,2), o que gerava um choicesfield VAZIO e gerava erro no form que não aceitava 	  este campo "vazio".
	- A SOLUÇÃO já existia: no nosso form já tinhamos um __init__ super que recebia este objeto atual e renderizava o CHOICEFIELDS com um queryset que carregava ali na hora os objetos existentes.
